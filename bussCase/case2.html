<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhancing SRD with Intelligent Path Selection - Business Case Analysis</title>
    <link rel="stylesheet" href="BCstyle.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body>
    <div class="case-analysis-container">
        <header class="case-header">
            <nav class="back-nav">
                <a href="../index.html#srd2-business-case" class="back-button">
                    <i class="fas fa-arrow-left"></i>
                    Back to Business Case
                </a>
                
            </nav>
            <h1>Enhancing AWS Global Accelerator with Advanced Algorithmic Techniques</h1>
            <div class="case-meta">
                <!-- <span class="meta-item">
                    <i class="fas fa-code"></i>
                    Role: Algorithmic Programming Engineer
                </span> -->
                <span class="meta-item">
                    <i class="fas fa-project-diagram"></i>
                    Domain: Network Optimization & Machine Learning
                </span>
            </div>
        </header>

        <main class="case-content">
            <section class="section">
                <h2 class="section-title">Overview</h2>
                <p class="content-text">
                    AWS Global Accelerator improves the performance and availability of globally distributed applications by routing traffic to optimal AWS endpoints using Anycast IP addresses and real-time intelligent routing. Recent integrations with AI/ML technologies, such as Graph Neural Networks (GNNs), have enhanced traffic prediction capabilities. However, increasing demands for ultra-low-latency, high-resilience applications necessitate further optimization. This business case proposes four enhancements: (1) hybrid GNN and time-series models for traffic forecasting, (2) adaptive PageRank with traffic load feedback, (3) efficient encoding of routing policies using Huffman and arithmetic coding. These improvements aim to reduce latency, enhance availability, and lower operational costs.
                </p>
            </section>

            <section class="section">
                <h2 class="section-title">Current Algorithms Used by AWS Global Accelerator</h2>
                <ul class="content-list">
                    <li>
                        <strong>Intelligent Routing:</strong>
                        <ul>
                            Uses real-time network health metrics (e.g., latency, packet loss) to select optimal endpoints.it relies on shortest-path algorithms (e.g., Dijkstra's or Bellman-Ford) for dynamic routing, updated reactively based on endpoint health.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Anycast IP Routing:</strong>
                        <ul>
                            Uses Anycast IP addresses to route traffic to the nearest AWS edge location via Border Gateway Protocol (BGP).
                        </ul>
                    </li>
                    <li>
                        <strong>Graph Neural Networks (GNNs):</strong>
                        <ul>
                            AWS's GraphStorm framework models the network as a graph (nodes as endpoints, edges as connections) to predict traffic patterns.GNNs capture spatial and temporal dynamics, reducing prediction errors by up to 35% compared to traditional time-series models (e.g., ARIMA).
                        </ul>
                    </li>
                </ul>
            </section>

            <section class="section">
                <h2 class="section-title">Proposed Enhancements</h2>
                <div style="text-align: center; margin-top: 1rem;">
                    <!-- <h3>Flowchart</h3> -->
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border-light); border-radius: 8px; display: inline-block;">
                        <img src="../image/flow2.png" alt="flowchart" style="max-width: 300%; height: auto; display: block;">
                    </div>
                </div>
                <div class="enhancement-block">
                    <h3>1. Hybrid Graph Neural Network (GNN) + Time-Series Models for Traffic Forecasting</h3>
                    <p class="content-text">
                         Combine GNNs with classical time-series models (e.g., ARIMA, LSTM) to model both spatial (network topology) and temporal (traffic trends) dynamics. Use GNNs to capture network-wide relationships (e.g., endpoint dependencies). Integrate LSTM for temporal traffic patterns and ARIMA for residual error correction. Deploy the hybrid model on AWS edge nodes to predict traffic and guide proactive rerouting.
                    </p>
                </div>


            <div class="enhancement-block">
                <h3>2. Adaptive PageRank with Traffic Load Feedback</h3>
                <p class="content-text">
                    Extend the PageRank algorithm by incorporating real-time traffic load and endpoint health into a dynamic priority score for routing.
                </p>
                
                <div class="enhancement-header" onclick="toggleDetails(this)">
                    <h4>View Implementation Details</h4>
                    <i class="fas fa-chevron-down dropdown-icon"></i>
                </div>
                <div class="enhancement-content">
                    <div class="implementation-part with-image">
                        <div class="implementation-text">
                            <p class="implementation-description">
                                <h3>PageRank Algorithm</h3>
                                Modify PageRank to weight edges based on real-time metrics (e.g., latency, bandwidth utilization). Update scores periodically using feedback loops from network telemetry. Use scores to prioritize endpoints, avoiding overloaded or unhealthy nodes.                            </p>
                            <p class="assumptions-text">
                                <strong>Assumptions:</strong>The algorithm assumes a static directed graph with equal initial scores, uniform link weighting, synchronous updates, no sink handling, and stops on convergence or max iterations without using real-time traffic data.

                            </p>
                            <button class="view-code-btn" onclick="viewCode('ucs-ecmp')">
                                <i class="fas fa-code"></i>
                                View Code
                            </button>
                            <a href="../algos/pagerank.html" target="_blank" class="view-code-btn" style="margin-left: 10px; text-decoration: none; display: inline-block;">
                                <i class="fas fa-play"></i>
                                Watch Simulation
                            </a>
                        </div>
                        <div class="implementation-image">
                            <img src="../image/pagerank.png" alt="Uniform Cost Search Algorithm" />
                        </div>
                    </div>
                </div>
            </div>
        </section>




        <div class="enhancement-block">
            <h3>3. Efficient Encoding of Routing Policies Using Huffman and Arithmetic Coding</h3>
            <p class="content-text">
                Apply Huffman and arithmetic coding to compress routing metadata (e.g., path tables, endpoint priorities) for control-plane communications.            </p>
            
            <div class="enhancement-header" onclick="toggleDetails(this)">
                <h4>View Implementation Details</h4>
                <i class="fas fa-chevron-down dropdown-icon"></i>
            </div>
            <div class="enhancement-content">
                <div class="implementation-part with-image">
                    <div class="implementation-text">
                        <p class="implementation-description">
                            <h3>Huffman Coding</h3>
                            Use Huffman coding for frequent routing patterns and arithmetic coding for variable-length metadata. Integrate encoding into Global Accelerator's control plane to reduce data transmission size.                        <p class="assumptions-text">
                            <strong>Assumptions:</strong> This code assumes fixed input alphabets, independent symbol probabilities, known metadata length, in-memory decoding feasibility, no transmission errors, and that routing patterns follow frequency distributions suitable for Huffman and arithmetic compression.

                        </p>
                        <button class="view-code-btn" onclick="viewCode('encoding')">
                            <i class="fas fa-code"></i>
                            View Code
                        </button>
                    </div>
                    <div class="implementation-image">
                        <img src="../image/huffman.png" alt="Uniform Cost Search Algorithm" />
                    </div>
                </div>
            </div>
        </div>
    </section>













    <section class="section">
        <h2 class="section-title">Space-Time Complexity Analysis</h2>
        <div class="complexity-table-container">
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Component</th>
                        <th>Time Complexity</th>
                        <th>Space Complexity</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="component-cell">GNN-Based Traffic Prediction</td>
                        <td>O(e * v²) training<br>O(v²) inference</td>
                        <td>O(v + e)</td>
                    </tr>
                    <tr>
                        <td class="component-cell">Hybrid GNN + Time-Series Models</td>
                        <td>O(e * v² + t) training<br>O(v² + d) inference</td>
                        <td>O(v + e + d)</td>
                    </tr>
                    <tr>
                        <td class="component-cell">Adaptive PageRank</td>
                        <td>O(m + n log n) per iteration</td>
                        <td>O(n + m)</td>
                    </tr>
                    <tr>
                        <td class="component-cell">Huffman + Arithmetic Coding</td>
                        <td>O(k log k) Huffman<br>O(k) Arithmetic</td>
                        <td>O(k)</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </section>


            <section class="section">
                <h2 class="section-title">Trade-offs</h2>
                <ul class="content-list">
                    <li>Hybrid GNN + time-series models and RL increase CPU and memory usage on edge nodes.</li>
                    <li>ML training require significant computational resources and data storage.</li>
                    <li>Complexity: Adaptive PageRank and encoding schemes add system complexity, requiring skilled maintenance.</li>
                    <li>Real-time inference and encoding/decoding may introduce microseconds of delay in routing decisions.</li>
                </ul>
            </section>
        </section>

        <div class="complexity-summary">
            <h3>Summary</h3>
            <p class="summary-text">
                The proposed enhancements to AWS Global Accelerator—hybrid GNN + time-series models, adaptive PageRank, efficient encoding, and RL-based traffic engineering—address limitations in reactive routing, load balancing, and control-plane efficiency. These improvements reduce latency, enhance availability, and lower costs, strengthening AWS's position in global networking. While computational and complexity trade-offs exist, the performance gains and scalability justify the enhancements, enabling AWS to meet the demands of modern, latency-sensitive applications.            </p>
        </div>

        <div class="citations-section">
            <h2 class="section-title">References</h2>
            <ol class="citations-list">
                <li>AWS. (2023). AWS Global Accelerator. <a href="https://aws.amazon.com/global-accelerator/" target="_blank">https://aws.amazon.com/global-accelerator/</a></li>
                <li>Balaji, V. (2023). AWS Global Accelerator. <a href="https://medium.com/@vasanthabalaji/aws-global-accelerator-c2fed772508c" target="_blank">https://medium.com/@vasanthabalaji/aws-global-accelerator-c2fed772508c</a></li>
                <li>GeeksforGeeks. (2023). Amazon Web Services - Global Accelerator. <a href="https://www.geeksforgeeks.org/amazon-web-services-global-accelerator/" target="_blank">https://www.geeksforgeeks.org/amazon-web-services-global-accelerator/</a></li>
                <li>AWS. (2023). Zero Rating and IP Address Management Made Easy: CloudFront's New Anycast Static IPs Explained. <a href="https://aws.amazon.com/blogs/networking-and-content-delivery/zero-rating-and-ip-address-management-made-easy-cloudfronts-new-anycast-static-ips-explained/" target="_blank">https://aws.amazon.com/blogs/networking-and-content-delivery/zero-rating-and-ip-address-management-made-easy-cloudfronts-new-anycast-static-ips-explained/</a></li>
                <li>AWS. (2023). Mitigating Risk: AWS Backbone Network Traffic Prediction Using GraphStorm. <a href="https://aws.amazon.com/blogs/machine-learning/mitigating-risk-aws-backbone-network-traffic-prediction-using-graphstorm/" target="_blank">https://aws.amazon.com/blogs/machine-learning/mitigating-risk-aws-backbone-network-traffic-prediction-using-graphstorm/</a></li>
                <li>GeeksforGeeks. (2023). Huffman Coding | Greedy Algo-3. <a href="https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/" target="_blank">https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/</a></li>
            </ol>
        </div>
    </section>

        </main>
    </div>

    <div id="codeModal" class="code-modal">
        <div class="code-modal-content">
            <div class="code-modal-header">
                <h3 id="modalTitle">Code Implementation</h3>
                <button class="close-modal" onclick="closeCodeModal()">&times;</button>
            </div>
            <div class="code-modal-body">
                <pre><code class="python" id="modalCode"></code></pre>
            </div>
        </div>
    </div>

    <script>
    function toggleDetails(element) {
        const content = element.nextElementSibling;
        const icon = element.querySelector('.dropdown-icon');
        
        content.classList.toggle('show');
        icon.classList.toggle('rotate');
    }

    function scrollToCase() {
        // Wait for the page to load
        window.addEventListener('load', function() {
            // Get the case card element
            const caseCard = document.querySelector('.case-card:first-child');
            if (caseCard) {
                // Smooth scroll to the case card
                caseCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        });
    }

    const codeImplementations = {
        'ucs-ecmp': {
            title: 'Pagerank algorithm ',
            code: `from collections import defaultdict

# Data Structure for Directed Graph
class Graph:
    def __init__(self):
        self.graph = defaultdict(list)  # Adjacency list: {node: [neighbors]}
    
    def add_edge(self, u, v):
        self.graph[u].append(v)
    
    def get_nodes(self):
        return list(self.graph.keys())
    
    def get_outgoing(self, node):
        return self.graph[node]

# Basic PageRank Algorithm
class PageRank:
    def __init__(self, graph, damping_factor=0.85, max_iterations=100, tolerance=1e-6):
        self.graph = graph
        self.damping_factor = damping_factor
        self.max_iterations = max_iterations
        self.tolerance = tolerance
        self.scores = defaultdict(lambda: 1.0)  # Initial scores
    
    def compute_page_rank(self):
        nodes = self.graph.get_nodes()
        n = len(nodes)
        new_scores = defaultdict(float)
        
        for _ in range(self.max_iterations):
            total_diff = 0.0
            for node in nodes:
                rank_sum = 0.0
                # Sum contributions from incoming links
                for src in nodes:
                    if node in self.graph.get_outgoing(src):
                        out_degree = len(self.graph.get_outgoing(src))
                        if out_degree > 0:
                            rank_sum += self.scores[src] / out_degree
                # Update score with damping factor
                new_rank = (1 - self.damping_factor) / n + self.damping_factor * rank_sum
                total_diff += abs(new_rank - self.scores[node])
                new_scores[node] = new_rank
            
            self.scores.update(new_scores)
            if total_diff < self.tolerance:
                break
        
        return self.scores

# Example Usage
def main():
    g = Graph()
    g.add_edge(1, 2)
    g.add_edge(1, 3)
    g.add_edge(2, 3)
    g.add_edge(2, 4)
    g.add_edge(3, 4)
    g.add_edge(4, 1)
    
    pr = PageRank(g)
    scores = pr.compute_page_rank()
    print("PageRank Scores:", dict(scores))

if __name__ == "__main__":
    main()`
        },
        'encoding': {
            title: 'Huffman and Arithmetic Coding Implementation',
            code: `from collections import Counter
import heapq
from decimal import Decimal, getcontext

# Huffman Coding for Frequent Routing Patterns
class HuffmanNode:
    def __init__(self, symbol, freq):
        self.symbol = symbol
        self.freq = freq
        self.left = None
        self.right = None
    
    def __lt__(self, other):
        return self.freq < other.freq

class HuffmanCoding:
    def __init__(self):
        self.codes = {}
    
    def build_tree(self, patterns):
        freq = Counter(patterns)
        heap = [HuffmanNode(symbol, freq) for symbol, freq in freq.items()]
        heapq.heapify(heap)
        
        while len(heap) > 1:
            left = heapq.heappop(heap)
            right = heapq.heappop(heap)
            parent = HuffmanNode(None, left.freq + right.freq)
            parent.left = left
            parent.right = right
            heapq.heappush(heap, parent)
        
        self._generate_codes(heap[0], "")
    
    def _generate_codes(self, node, code):
        if node.symbol is not None:
            self.codes[node.symbol] = code or "0"
        else:
            if node.left:
                self._generate_codes(node.left, code + "0")
            if node.right:
                self._generate_codes(node.right, code + "1")
    
    def encode(self, patterns):
        return "".join(self.codes[pattern] for pattern in patterns)
    
    def decode(self, encoded):
        decoded = []
        current_code = ""
        for bit in encoded:
            current_code += bit
            for symbol, code in self.codes.items():
                if current_code == code:
                    decoded.append(symbol)
                    current_code = ""
                    break
        return decoded

# Arithmetic Coding for Variable-Length Metadata
class ArithmeticCoding:
    def __init__(self):
        self.probabilities = {}
    
    def build_probabilities(self, metadata):
        total = len(metadata)
        freq = Counter(metadata)
        self.probabilities = {char: freq[char] / total for char in freq}
    
    def encode(self, metadata):
        getcontext().prec = 50
        low = Decimal(0.0)
        high = Decimal(1.0)
        range_width = high - low
        
        for char in metadata:
            prob = Decimal(self.probabilities[char])
            high = low + range_width * prob
            low = low
            range_width = high - low
        
        return (low + high) / 2
    
    def decode(self, value, length):
        getcontext().prec = 50
        decoded = []
        for _ in range(length):
            current = Decimal(value)
            cumulative = Decimal(0.0)
            for char, prob in self.probabilities.items():
                cumulative += Decimal(prob)
                if current < cumulative:
                    decoded.append(char)
                    high = cumulative
                    low = cumulative - Decimal(prob)
                    value = (current - low) / (high - low)
                    break
        return "".join(decoded)

# Global Accelerator Control Plane Integration
class GlobalAcceleratorEncoder:
    def __init__(self):
        self.huffman = HuffmanCoding()
        self.arithmetic = ArithmeticCoding()
    
    def encode_routing_data(self, routing_patterns, metadata):
        # Encode frequent routing patterns with Huffman coding
        self.huffman.build_tree(routing_patterns)
        encoded_patterns = self.huffman.encode(routing_patterns)
        
        # Encode variable-length metadata with arithmetic coding
        self.arithmetic.build_probabilities(metadata)
        encoded_metadata = self.arithmetic.encode(metadata)
        
        return encoded_patterns, encoded_metadata
    
    def decode_routing_data(self, encoded_patterns, encoded_metadata, metadata_length):
        # Decode routing patterns
        decoded_patterns = self.huffman.decode(encoded_patterns)
        
        # Decode metadata
        decoded_metadata = self.arithmetic.decode(encoded_metadata, metadata_length)
        
        return decoded_patterns, decoded_metadata

# Example Usage
def main():
    # Sample routing patterns (e.g., endpoint paths) and metadata
    routing_patterns = ["path1", "path2", "path1", "path3", "path2", "path1"]
    metadata = "config:region=us-west-2,priority=high"
    
    encoder = GlobalAcceleratorEncoder()
    
    # Encode data
    encoded_patterns, encoded_metadata = encoder.encode_routing_data(routing_patterns, metadata)
    print(f"Encoded Patterns: {encoded_patterns}")
    print(f"Encoded Metadata: {encoded_metadata}")
    
    # Decode data
    decoded_patterns, decoded_metadata = encoder.decode_routing_data(
        encoded_patterns, encoded_metadata, len(metadata)
    )
    print(f"Decoded Patterns: {decoded_patterns}")
    print(f"Decoded Metadata: {decoded_metadata}")

if __name__ == "__main__":
    main()`
        }
    };

    function viewCode(implementationType) {
        const modal = document.getElementById('codeModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalCode = document.getElementById('modalCode');
        
        if (codeImplementations[implementationType]) {
            modalTitle.textContent = codeImplementations[implementationType].title;
            modalCode.textContent = codeImplementations[implementationType].code;
            modal.style.display = 'block';
        }
    }

    function closeCodeModal() {
        const modal = document.getElementById('codeModal');
        modal.style.display = 'none';
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
        const modal = document.getElementById('codeModal');
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    }
    </script>
</body>
</html>
